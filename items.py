from bundlewrap.exceptions import BundleError
import re

pkg_apt = {}
files = {}
svc_systemd = {}


def add_dot(url):
    if url[-1] != '.':
        url += '.'

    return url


def add_to_list_or_create(ilist, list_key, value):
    if list_key not in ilist:
        ilist[list_key] = []

    ilist[list_key] += [value, ]


def convert_to_config_string(value):
    if isinstance(value, list):
        value = ','.join(value)
    elif isinstance(value, bool):
        value = 'yes' if value else 'no'
    elif value is None:
        value = ''

    return value


def generate_content(dns_config, default_config):
    content = [
        '# Autogenerated by bundlewrap'
    ]
    for dns_config_key, value in dns_config.items():
        default_value = default_config.get(dns_config_key, {}).get('default_value', None)
        mandatory = default_config.get(dns_config_key, {}).get('mandatory', False)
        comment = default_config.get(dns_config_key, {}).get('comment', None)

        if comment:
            content += [
                '#################################',
                '# {}'.format(default_config.get(dns_config_key, {}).get('comment', '')),
                '#',
            ]

            if not mandatory:
                content += [
                    '# {}={}'.format(dns_config_key, convert_to_config_string(default_value)),
                ]

        if default_value != value or mandatory:
            value = convert_to_config_string(value)

            content += [
                '{}={}'.format(dns_config_key, value),
            ]

        content += [
            '',  # one empty line between the configs
        ]

    content += [
        '',  # one empty line at the end of the file
    ]

    return content


svc_systemd['pdns'] = {'needs': ['pkg_apt:pdns-server', ], }


pdns_default_config = {
    '8bit-dns': {'comment': '8bit-dns	Allow 8bit dns queries', 'default_value': False},
    'allow-axfr-ips': {'comment': 'allow-axfr-ips	Allow zonetransfers only to these subnets',
                       'default_value': ['127.0.0.0/8', '::1']},
    'allow-dnsupdate-from': {
        'comment': 'allow-dnsupdate-from	A global setting to allow DNS updates from these IP ranges.',
        'default_value': ['127.0.0.0/8', '::1']},
    'allow-notify-from': {
        'comment': 'allow-notify-from	Allow AXFR NOTIFY from these IP ranges. If empty, drop all incoming notifies.',
        'default_value': ['0.0.0.0/0', '::/0']},
    # 'allow-recursion': {'comment': 'allow-recursion	List of subnets that are allowed to recurse',
    #                     'default_value': ['0.0.0.0/0']},
    'allow-unsigned-notify': {
        'comment': 'allow-unsigned-notify	Allow unsigned notifications for TSIG secured domains',
        'default_value': True},
    'allow-unsigned-supermaster': {
        'comment': 'allow-unsigned-supermaster	Allow supermasters to create zones without TSIG signed NOTIFY',
        'default_value': True},
    'also-notify': {'comment': 'also-notify	When notifying a domain, also notify these nameservers',
                    'default_value': ''},
    'any-to-tcp': {'comment': 'any-to-tcp	Answer ANY queries with tc=1, shunting to TCP', 'default_value': True},
    'api': {'comment': 'api	Enable/disable the REST API (including HTTP listener)', 'default_value': False},
    'api-key': {'comment': 'api-key	Static pre-shared authentication key for access to the REST API',
                'default_value': ''},
    'api-logfile': {'comment': 'api-logfile	Location of the server logfile (used by the REST API)',
                    'default_value': '/var/log/pdns.log'},
    'api-readonly': {'comment': 'api-readonly	Disallow data modification through the REST API when set',
                     'default_value': False},
    'axfr-lower-serial': {'comment': 'axfr-lower-serial	Also AXFR a zone from a master with a lower serial',
                          'default_value': False},
    'cache-ttl': {'comment': 'cache-ttl	Seconds to store packets in the PacketCache', 'default_value': 20},
    'carbon-interval': {'comment': 'carbon-interval	Number of seconds between carbon (graphite) updates',
                        'default_value': 30},
    'carbon-ourname': {'comment': 'carbon-ourname	If set, overrides our reported hostname for carbon stats',
                       'default_value': ''},
    'carbon-server': {
        'comment': 'carbon-server	If set, send metrics in carbon (graphite) format to this server IP address',
        'default_value': ''},
    'chroot': {'comment': 'chroot	If set, chroot to this directory for more security', 'default_value': ''},
    'config-dir': {'comment': 'config-dir	Location of configuration directory (pdns.conf)',
                   'default_value': '/etc/powerdns'},
    'config-name': {'comment': 'config-name	Name of this virtual configuration - will rename the binary image',
                    'default_value': ''},
    'control-console': {'comment': 'control-console	Debugging switch - don\'t use', 'default_value': False},
    'daemon': {'comment': 'daemon	Operate as a daemon', 'default_value': False},
    'default-ksk-algorithm': {'comment': 'default-ksk-algorithm	Default KSK algorithm', 'default_value': 'ecdsa256'},
    'default-ksk-size': {'comment': 'default-ksk-size	Default KSK size (0 means default)', 'default_value': 0},
    'default-soa-edit': {'comment': 'default-soa-edit	Default SOA-EDIT value', 'default_value': ''},
    'default-soa-edit-signed': {'comment': 'default-soa-edit-signed	Default SOA-EDIT value for signed zones',
                                'default_value': ''},
    'default-soa-mail': {
        'comment': 'default-soa-mail	mail address to insert in the SOA record if none set in the backend',
        'default_value': ''},
    'default-soa-name': {'comment': 'default-soa-name	name to insert in the SOA record if none set in the backend',
                         'default_value': 'a.misconfigured.powerdns.server'},
    'default-ttl': {'comment': 'default-ttl	Seconds a result is valid if not set otherwise', 'default_value': 3600},
    'default-zsk-algorithm': {'comment': 'default-zsk-algorithm	Default ZSK algorithm', 'default_value': ''},
    'default-zsk-size': {'comment': 'default-zsk-size	Default ZSK size (0 means default)', 'default_value': 0},
    'direct-dnskey': {'comment': 'direct-dnskey	Fetch DNSKEY RRs from backend during DNSKEY synthesis',
                      'default_value': False},
    'disable-axfr': {'comment': 'disable-axfr	Disable zonetransfers but do allow TCP queries',
                     'default_value': False},
    'disable-axfr-rectify': {
        'comment': 'disable-axfr-rectify	'
                   'Disable the rectify step during an outgoing AXFR. Only required for regression testing.',
        'default_value': False},
    'disable-syslog': {
        'comment': 'disable-syslog	Disable logging to syslog, useful when running inside a supervisor that logs stdout',
        'default_value': False},
    'disable-tcp': {'comment': 'disable-tcp	Do not listen to TCP queries', 'default_value': False},
    'distributor-threads': {
        'comment': 'distributor-threads	Default number of Distributor (backend) threads to start',
        'default_value': 3},
    'dname-processing': {'comment': 'dname-processing	If we should support DNAME records', 'default_value': False},
    'dnssec-key-cache-ttl': {'comment': 'dnssec-key-cache-ttl	Seconds to cache DNSSEC keys from the database',
                             'default_value': 30},
    'dnsupdate': {'comment': 'dnsupdate	Enable/Disable DNS update (RFC2136) support. Default is no.',
                  'default_value': False},
    'do-ipv6-additional-processing': {'comment': 'do-ipv6-additional-processing	Do AAAA additional processing',
                                      'default_value': True},
    'domain-metadata-cache-ttl': {
        'comment': 'domain-metadata-cache-ttl	Seconds to cache domain metadata from the database',
        'default_value': 60},
    'edns-subnet-processing': {'comment': 'edns-subnet-processing	If we should act on EDNS Subnet options',
                               'default_value': False},
    'entropy-source': {'comment': 'entropy-source	If set, read entropy from this file',
                       'default_value': '/dev/urandom'},
    'expand-alias': {'comment': 'expand-alias	Expand ALIAS records', 'default_value': False},
    # 'experimental-lua-policy-script': {'comment': 'experimental-lua-policy-script	Lua script for the policy engine',
    #                                    'default_value': ''},
    'forward-dnsupdate': {
        'comment': 'forward-dnsupdate	'
                   'A global setting to allow DNS update packages that are for a Slave domain, '
                   'to be forwarded to the master.',
        'default_value': True},
    'forward-notify': {
        'comment': 'forward-notify	'
                   'IP addresses to forward received notifications to regardless of master or slave settings',
        'default_value': ''},
    'guardian': {'comment': 'guardian	Run within a guardian process', 'default_value': False},
    'include-dir': {'comment': 'include-dir	Include *.conf files from this directory', 'default_value': ''},
    'launch': {'comment': 'launch	Which backends to launch and order to query them in', 'default_value': None},
    'load-modules': {'comment': 'load-modules	Load this module - supply absolute or relative path',
                     'default_value': ''},
    'local-address': {'comment': 'local-address	Local IP addresses to which we bind', 'default_value': '0.0.0.0'},
    'local-address-nonexist-fail': {
        'comment': 'local-address-nonexist-fail	Fail to start if one or more of '
                   'the local-address\'s do not exist on this server',
        'default_value': True},
    'local-ipv6': {'comment': 'local-ipv6	Local IP address to which we bind', 'default_value': '::'},
    'local-ipv6-nonexist-fail': {
        'comment': 'local-ipv6-nonexist-fail	Fail to start if one or more of '
                   'the local-ipv6 addresses do not exist on this server',
        'default_value': True},
    'local-port': {'comment': 'local-port	The port on which we listen', 'default_value': 53},
    'log-dns-details': {'comment': 'log-dns-details	If PDNS should log DNS non-erroneous details',
                        'default_value': False},
    'log-dns-queries': {'comment': 'log-dns-queries	If PDNS should log all incoming DNS queries',
                        'default_value': False},
    'log-timestamp': {'comment': 'log-timestamp	Print timestamps in log lines', 'default_value': True},
    'logging-facility': {'comment': 'logging-facility	Log under a specific facility', 'default_value': ''},
    'loglevel': {'comment': 'loglevel	Amount of logging. Higher is more. Do not set below 3', 'default_value': 4},
    'lua-axfr-script': {'comment': 'lua-axfr-script	Script to be used to edit incoming AXFRs', 'default_value': ''},
    'lua-dnsupdate-policy-script': {
        'comment': 'lua-dnsupdate-policy-script	Lua script with DNS update policy handler', 'default_value': ''},
    'lua-prequery-script': {'comment': 'lua-prequery-script	Lua script with prequery handler (DO NOT USE)',
                            'default_value': ''},
    'master': {'comment': 'master	Act as a master', 'default_value': False},
    'max-cache-entries': {'comment': 'max-cache-entries	Maximum number of entries in the query cache',
                          'default_value': 1000000},
    'max-ent-entries': {'comment': 'max-ent-entries	Maximum number of empty non-terminals in a zone',
                        'default_value': 100000},
    'max-nsec3-iterations': {'comment': 'max-nsec3-iterations	Limit the number of NSEC3 hash iterations',
                             'default_value': 500},
    'max-packet-cache-entries': {'comment': 'max-packet-cache-entries	Maximum number of entries in the packet cache',
                                 'default_value': 1000000},
    'max-queue-length': {'comment': 'max-queue-length	Maximum queuelength before considering situation lost',
                         'default_value': 5000},
    'max-signature-cache-entries': {
        'comment': 'max-signature-cache-entries	Maximum number of signatures cache entries', 'default_value': ''},
    'max-tcp-connection-duration': {
        'comment': 'max-tcp-connection-duration	Maximum time in seconds that a '
                   'TCP DNS connection is allowed to stay open.',
        'default_value': 0},
    'max-tcp-connections': {'comment': 'max-tcp-connections	Maximum number of TCP connections', 'default_value': 20},
    'max-tcp-connections-per-client': {
        'comment': 'max-tcp-connections-per-client	Maximum number of simultaneous TCP connections per client',
        'default_value': 0},
    'max-tcp-transactions-per-conn': {
        'comment': 'max-tcp-transactions-per-conn	Maximum number of subsequent queries per TCP connection',
        'default_value': 0},
    'module-dir': {'comment': 'module-dir	Default directory for modules', 'default_value': '/usr/lib/powerdns'},
    'negquery-cache-ttl': {'comment': 'negquery-cache-ttl	Seconds to store negative query results in the QueryCache',
                           'default_value': 60},
    'no-shuffle': {'comment': 'no-shuffle	Set this to prevent random shuffling of answers - for regression testing',
                   'default_value': 'off'},
    'non-local-bind': {
        'comment': 'non-local-bind	Enable binding to non-local addresses by using FREEBIND / BINDANY socket options',
        'default_value': False},
    'only-notify': {'comment': 'only-notify	Only send AXFR NOTIFY to these IP addresses or netmasks',
                    'default_value': ['0.0.0.0/0', '::/0']},
    'out-of-zone-additional-processing': {
        'comment': 'out-of-zone-additional-processing	Do out of zone additional processing', 'default_value': True},
    'outgoing-axfr-expand-alias': {'comment': 'outgoing-axfr-expand-alias	Expand ALIAS records during outgoing AXFR',
                                   'default_value': False},
    'overload-queue-length': {'comment': 'overload-queue-length	Maximum queuelength moving to packetcache only',
                              'default_value': 0},
    'prevent-self-notification': {
        'comment': 'prevent-self-notification	Don\'t send notifications to what we think is ourself',
        'default_value': True},
    'query-cache-ttl': {'comment': 'query-cache-ttl	Seconds to store query results in the QueryCache',
                        'default_value': 20},
    'query-local-address': {'comment': 'query-local-address	Source IP address for sending queries',
                            'default_value': '0.0.0.0'},
    'query-local-address6': {'comment': 'query-local-address6	Source IPv6 address for sending queries',
                             'default_value': '::'},
    'query-logging': {'comment': 'query-logging	Hint backends that queries should be logged',
                      'default_value': False},
    'queue-limit': {'comment': 'queue-limit	Maximum number of milliseconds to queue a query', 'default_value': 1500},
    'receiver-threads': {'comment': 'receiver-threads	Default number of receiver threads to start',
                         'default_value': 1},
    # 'recursive-cache-ttl': {'comment': 'recursive-cache-ttl	'
    #                                    'Seconds to store packets for recursive queries in the PacketCache',
    #                                    'default_value': 10},
    # 'recursor': {'comment': 'recursor	If recursion is desired, IP address of a recursing nameserver',
    #              'default_value': False},
    'resolver': {'comment': 'resolver	Use this resolver for ALIAS and the internal stub resolver',
                 'default_value': False},
    'retrieval-threads': {'comment': 'retrieval-threads	Number of AXFR-retrieval threads for slave operation',
                          'default_value': 2},
    'reuseport': {
        'comment': 'reuseport	Enable higher performance on compliant kernels by using SO_REUSEPORT '
                   'allowing each receiver thread to open its own socket',
        'default_value': False},
    'security-poll-suffix': {
        'comment': 'security-poll-suffix	Domain name from which to query security update notifications',
        'default_value': 'secpoll.powerdns.com.'},
    'server-id': {
        'comment': 'server-id	Returned when queried for \'id.server\' TXT or NSID, defaults to hostname '
                   '- disabled or custom',
        'default_value': ''},
    'setgid': {'comment': 'setgid	If set, change group id to this gid for more security', 'default_value': '',
               'mandatory': True},
    'setuid': {'comment': 'setuid	If set, change user id to this uid for more security', 'default_value': '',
               'mandatory': True},
    'signing-threads': {'comment': 'signing-threads	Default number of signer threads to start', 'default_value': 3},
    'slave': {'comment': 'slave	Act as a slave', 'default_value': False},
    'slave-cycle-interval': {'comment': 'slave-cycle-interval	Schedule slave freshness checks once every .. seconds',
                             'default_value': 60},
    'slave-renotify': {'comment': 'slave-renotify	If we should send out notifications for slaved updates',
                       'default_value': False},
    'soa-expire-default': {'comment': 'soa-expire-default	Default SOA expire', 'default_value': 604800},
    'soa-minimum-ttl': {'comment': 'soa-minimum-ttl	Default SOA minimum ttl', 'default_value': 3600},
    'soa-refresh-default': {'comment': 'soa-refresh-default	Default SOA refresh', 'default_value': 10800},
    'soa-retry-default': {'comment': 'soa-retry-default	Default SOA retry', 'default_value': 3600},
    'socket-dir': {'comment': 'socket-dir	Where the controlsocket will live, /var/run when unset and not chrooted',
                   'default_value': ''},
    'tcp-control-address': {
        'comment': 'tcp-control-address	If set, PowerDNS can be controlled over TCP on this address',
        'default_value': ''},
    'tcp-control-port': {'comment': 'tcp-control-port	If set, PowerDNS can be controlled over TCP on this address',
                         'default_value': 53000},
    'tcp-control-range': {
        'comment': 'tcp-control-range	If set, remote control of PowerDNS is possible over these networks only',
        'default_value': ['127.0.0.0/8', '10.0.0.0/8', '192.168.0.0/16', '172.16.0.0/12', '::1/128', 'fe80::/10']},
    'tcp-control-secret': {
        'comment': 'tcp-control-secret	If set, PowerDNS can be controlled over TCP after passing this secret',
        'default_value': ''},
    'tcp-fast-open': {
        'comment': 'tcp-fast-open	Enable TCP Fast Open support on the listening sockets, using the supplied '
                   'numerical value as the queue size',
        'default_value': 0},
    'tcp-idle-timeout': {
        'comment': 'tcp-idle-timeout	Maximum time in seconds that a TCP DNS connection is allowed to stay '
                   'open while being idle',
        'default_value': 5},
    'traceback-handler': {'comment': 'traceback-handler	Enable the traceback handler (Linux only)',
                          'default_value': True},
    'trusted-notification-proxy': {'comment': 'trusted-notification-proxy	IP address of incoming notification proxy',
                                   'default_value': ''},
    'udp-truncation-threshold': {'comment': 'udp-truncation-threshold	Maximum UDP response size before we truncate',
                                 'default_value': 1680},
    'version-string': {'comment': 'version-string	PowerDNS version in packets - full, anonymous, powerdns or custom',
                       'default_value': 'full'},
    'webserver': {'comment': 'webserver	Start a webserver for monitoring (api=yes also enables the HTTP listener)',
                  'default_value': False},
    'webserver-address': {'comment': 'webserver-address	IP Address of webserver/API to listen on',
                          'default_value': '127.0.0.1'},
    'webserver-allow-from': {
        'comment': 'webserver-allow-from	Webserver/API access is only allowed from these subnets',
        'default_value': ['127.0.0.1', '::1']},
    'webserver-password': {'comment': 'webserver-password	Password required for accessing the webserver',
                           'default_value': ''},
    'webserver-port': {'comment': 'webserver-port	Port of webserver/API to listen on', 'default_value': 8081},
    'webserver-print-arguments': {'comment': 'webserver-print-arguments	If the webserver should print arguments',
                                  'default_value': False},
    'write-pid': {'comment': 'write-pid	Write a PID file', 'default_value': True},
    'xfr-max-received-mbytes': {
        'comment': 'xfr-max-received-mbytes	Maximum number of megabytes received from an incoming XFR',
        'default_value': 100},
}

# set pdns_config to pdns_default_config
pdns_configs = {x: y.get('default_value', None) for (x, y) in pdns_default_config.items()}.copy()

# set this to known values
pdns_configs.update({
    'include-dir': '/etc/powerdns/pdns.d',
    'launch': '',
    'security-poll-suffix': '',
    'setgid': 'pdns',
    'setuid': 'pdns',
})

recursor_config = node.metadata.get('powerdns', {}).get('recursor', {})

if recursor_config.get('enabled', False):
    pdns_configs.update({
        'local-address': '127.0.0.1',
        'local-port': 5300,
    })


pdns_configs.update(node.metadata.get('powerdns', {}).get('config', {}))

files = {
    '/etc/powerdns/pdns.conf': {
        'content': '\n'.join(generate_content(dns_config=pdns_configs, default_config=pdns_default_config)) + '\n',
        'mode': "0600",
        'owner': 'root',
        'group': 'root',
        'triggers': [
            "svc_systemd:pdns:restart"
        ],
    }
}

dnssec_db = node.metadata\
    .get('powerdns', {}).get('backends', {})\
    .get('bind', {})\
    .get('config', {})\
    .get('bind-dnssec-db', '/var/lib/powerdns/bind-dnssec-db.sqlite3')


actions = {
    "create_dnssec_db": {
        'command': "pdnsutil create-bind-db {dnssec_db}".format(dnssec_db=dnssec_db),
        'unless': "test -f {dnssec_db}".format(dnssec_db=dnssec_db),
        'cascade_skip': False,
        'needs': ["pkg_apt:pdns-server"],
        'triggers': ['svc_systemd:pdns:restart'],
    },
}

directories = {}
zonefiles = {}
zones_dnssec = {}

for backend, config in node.metadata.get('powerdns', {}).get('backends', {}).items():
    apt = config.get('apt', 'pdns-backend-{}'.format(backend))
    pkg_apt[apt] = {
       'installed': True,
       'needs': ['pkg_apt:pdns-server'],
       'needed_by': ['svc_systemd:pdns']
    }

    backend_config = {}
    backend_default_config = {}
    backend_add_config = {}
    backend_config_filename = 'pdns.local.{}.conf'.format(backend)

    if backend == 'gmysql':
        backend_default_config = {
            'launch+': {'default_value': ''},  # no comment, so we do not print the comment
            'gmysql-host': {'comment': '', 'default_value': 'localhost'},
            'gmysql-port': {'comment': '', 'default_value': '3306'},
            'gmysql-dbname': {'comment': '', 'default_value': ''},
            'gmysql-user': {'comment': '', 'default_value': ''},
            'gmysql-password': {'comment': '', 'default_value': ''},
            'gmysql-dnssec': {'comment': '', 'default_value': 'no'},
        }

        backend_add_config = {
            'launch+': 'gmysql',
        }
    elif backend == 'bind':
        backend_config_filename = 'bind.conf'
        backend_default_config = {
            'launch+': {'default_value': ''},  # no comment, so we do not print the comment
            'bind-check-interval': {'comment': 'bind-check-interval	Interval for zonefile changes', 'default_value': 0},
            'bind-config': {'comment': 'bind-config	Location of named.conf', 'default_value': ''},
            'bind-dnssec-db': {'comment': 'bind-dnssec-db	'
                                          'Filename to store & access our DNSSEC metadatabase, empty for none',
                               'default_value': ''},
            'bind-hybrid': {'comment': 'bind-hybrid	Store DNSSEC metadata in other backend', 'default_value': False},
            'bind-ignore-broken-records': {'comment': 'bind-ignore-broken-records	'
                                                      'Ignore records that are out-of-bound for the zone.',
                                           'default_value': False},
            'bind-supermaster-config': {'comment': 'bind-supermaster-config	Location of (part of) named.conf where '
                                                   'pdns can write zone-statements to', 'default_value': ''},
            'bind-supermaster-destdir': {'comment': 'bind-supermaster-destdir	Destination directory for newly '
                                                    'added slave zones', 'default_value': ''},
            'bind-supermasters': {'comment': 'bind-supermasters	List of IP-addresses of supermasters',
                                  'default_value': ''},
        }

        backend_add_config = {
            'launch+': 'bind',
            'bind-supermaster-config': '/var/lib/powerdns/supermaster.conf',
            'bind-supermaster-destdir': '/var/lib/powerdns/zones.slave.d',
        }

        zonefile_directory = config.get('zonefile_directory', '/var/lib/powerdns/zones')

        directories[zonefile_directory] = {
            'owner': 'root',
            'group': 'pdns',
            'mode': "0750",
            'needs': ['pkg_apt:{}'.format(apt)],
        }

        named_config = [
            '# Debian default: supermaster created zones are written here:',
            'include "/var/lib/powerdns/supermaster.conf";',
        ]

        # load zonefiles
        for zone, zone_config in config.get('zones', {}).items():
            named_config.append('zone "{}" IN {{'.format(zone))
            named_config.append('    type {};'.format(zone_config.get('type', 'master')))
            named_config.append('    file "{}/{}.zone";'.format(zonefile_directory, zone))
            named_config.append('};')

            dnssec_config = zone_config.get('dnssec', None)

            if dnssec_config:
                keys = {}
                for key in dnssec_config.get('keys', []):
                    keys[key.get('public_key', {}).get('key', '')] = {
                        'private_key': repo.vault.decrypt_file('dnssec/{}'.format(
                            key.get('private_key_file', '{}.key'.format(zone)))).value,  # if not set, set to <zone>.key
                        'public_key': key.get('public_key', {}),
                        'active': key.get('active', False),
                    }

                if dnssec_config.get('disabled', False):
                    zones_dnssec[zone] = {
                        'disabled': True,
                    }
                else:
                    zones_dnssec[zone] = {
                        'keys': keys,
                        'nsec3': dnssec_config.get('nsec3', False),
                    }

            # create ns records we add a . to the end of every domain, since we assume they are absolute
            ns_records = []
            for ns in zone_config.get('name_servers', []):
                ns_records += [{'ttl': 86400, 'type': 'NS', 'value': add_dot(ns)}, ]

            actions['notify_zone_{}'.format(zone)] = {
                'command': "pdns_control notify {zone}".format(zone=zone),
                'triggered': True,
            }

            zonefiles[zone] = {
                'soa': {
                    'nameserver': zone_config.get('name_servers', [''])[0],
                    'postmaster': zone_config.get('soa', {}).get('hostmaster', 'hostmaster@ultrachaos.de'),
                    'refresh': zone_config.get('soa', {}).get('refresh', 14400),
                    'retry': zone_config.get('soa', {}).get('retry', 7200),
                    'expire': zone_config.get('soa', {}).get('expire', 604800),
                    'minimum': zone_config.get('soa', {}).get('minimum', 14400),
                },
                'records': {
                    '': ns_records,
                },
                'default_ttl': zone_config.get('default_ttl', 300),
                'zonefile_directory': zonefile_directory,
                'triggers': ['svc_systemd:pdns:restart', 'action:notify_zone_{}'.format(zone)],
                'needs': ['pkg_apt:pdns-server', 'directory:{}'.format(zonefile_directory)],
            }

            zone_type = zone_config.get('zone_type', "static")

            if zone_type == 'dyndns':
                zonefiles[zone]['dynamic'] = True
            elif zone_type == 'group':
                if 'group' not in zone_config:
                    raise BundleError("zonetype is group, but no group defined")

                for gnode in sorted(repo.nodes_in_group(zone_config['group'])):
                    for interface, interface_config in zone_config.get('interfaces', {}).items():
                        ip = gnode.metadata.get('interfaces', {})\
                            .get(interface, {})\
                            .get('ip_addresses', [None, ])[0]

                        # Remove Zone in hostname
                        gnode_name = re.sub("[.]{zone}$".format(zone=zone.replace('.', '[.]')), '', gnode.hostname)

                        if ip:
                            add_to_list_or_create(
                                zonefiles[zone]['records'],
                                '{net}.{name}'.format(net=interface, name=gnode_name),
                                {'type': 'A', 'value': ip}
                            )

                            if interface_config.get('cname', False):
                                add_to_list_or_create(
                                    zonefiles[zone]['records'],
                                    '{}'.format(gnode_name),
                                    {
                                        'type': 'CNAME', 'value': '{net}.{name}'.format(
                                            net=interface,
                                            name=gnode_name
                                        )
                                    }
                                )

                    for name, record in sorted(gnode.metadata.get('powerdns', {}).get('extra_srv_records', {}).items()):
                        add_to_list_or_create(
                            zonefiles[zone]['records'],
                            name,
                            {'type': 'SRV', 'value': (
                                record.get('priority', 10),
                                record.get('weight', 10),
                                record.get('port'),
                                record.get('server')
                            )}
                        )

            extra_records = zone_config.get('records', {})
            for name, items in sorted(extra_records.items()):
                for item in items:
                    add_to_list_or_create(
                        zonefiles[zone]['records'],
                        name,
                        {'type': item.get('type', 'A'), 'value': item.get('value', '')},
                    )

        files['/etc/powerdns/named.conf'] = {
            'content': '\n'.join(named_config) + '\n',
            'mode': "0640",
            'owner': 'root',
            'group': 'pdns',
            'triggers': [
                "svc_systemd:pdns:restart"
            ],
        }

    # set backend_config to backend_default_config
    backend_config = {x: y.get('default_value', None) for (x, y) in backend_default_config.items()}.copy()

    # set this to known values
    backend_config.update(backend_add_config)

    # overwrite config with configured values
    backend_config.update(config.get('config', {}))

    if config.get('enabled', False):
        files['/etc/powerdns/pdns.d/{}'.format(backend_config_filename)] = {
            'content': '\n'.join(generate_content(
                dns_config=backend_config,
                default_config=backend_default_config)) + '\n',
            'mode': "0640",
            'owner': 'root',
            'group': 'root',
            'triggers': [
                "svc_systemd:pdns:restart"
            ],
        }
    else:
        files['/etc/powerdns/pdns.d/{}'.format(backend_config_filename)] = {
            'delete': True,
            'triggers': [
                "svc_systemd:pdns:restart"
            ],
        }
